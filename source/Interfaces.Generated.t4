<#@ template hostspecific="false" language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

#nullable enable

<#
HashSet<string> interfaceTypes = new()
{
    "IGameInput",
    "IGameInputReading",
    "IGameInputDevice",
    "IGameInputDispatcher",
    "IGameInputForceFeedbackEffect",
    "IGameInputRawDeviceReport",
};

HashSet<string> lightInterfaceTypes = interfaceTypes.Select((n) => "Light" + n).ToHashSet();

const int TypeMarker_In = 0x01;
const int TypeMarker_Out = 0x02;
const int TypeMarker_Nullable = 0x04;
const int TypeMarker_Pointer = 0x08;

const int IUnknownMethodCount = 3;
int methodIndex = 0;

void DefineInterface(string name, Action makeMethods)
{
#>
    public sealed unsafe partial class <#= name #> : ComPtr
    {
        internal <#= name #>(IntPtr handle, bool ownsHandle) : base(handle, ownsHandle) { }
<#
    methodIndex = 0;
    makeMethods();
#>
    }
<#
}

void DefineLightInterface(string name, Action makeMethods)
{
    DefineInterface(name, makeMethods);
#>

    public unsafe ref partial struct Light<#= name #>
    {
        private IntPtr handle;
        private bool ownsHandle;

        public bool IsInvalid => handle == IntPtr.Zero;
        public bool IsClosed { get; private set; }

        internal Light<#= name #>(IntPtr handle, bool ownsHandle)
        {
            this.handle = handle;
            this.ownsHandle = ownsHandle;
            IsClosed = false;
        }

        public void Dispose()
        {
            if (!IsClosed && !IsInvalid && ownsHandle)
            {
                Marshal.Release(handle);
                IsClosed = true;
            }
        }

        public IntPtr DangerousGetHandle() => handle;

        public <#= name #> ToSafeHandle()
        {
            // Invalidate this handle
            IsClosed = true;

            // Move handle to the new instance
            var handle = this.handle;
            this.handle = IntPtr.Zero;
            return new(handle, ownsHandle);
        }

        public static implicit operator Light<#= name #>(<#= name #> instance)
        {
            return new(instance.DangerousGetHandle(), ownsHandle: false);
        }
<#
    methodIndex = 0;
    makeMethods();
#>
    }
<#
}

void ForwardMethod(string returnType, string name, params (string type, string name)[] parameters)
{
    _ForwardMethod("public", returnType, name, parameters);
}

void ForwardMethodInternally(string returnType, string name, params (string type, string name)[] parameters)
{
    _ForwardMethod("internal", returnType, name, parameters);
}

void ForwardMethodPrivately(string returnType, string name, params (string type, string name)[] parameters)
{
    _ForwardMethod("private", returnType, name, parameters);
}

void _ForwardMethod(string accessibility, string returnType, string name, params (string type, string name)[] _parameters)
{
    (string stripped, int flags) GetTypeModifiers(string type)
    {
        int flags = 0;

        if (type.StartsWith("in "))
        {
            flags |= TypeMarker_In;
            type = type[3..];
        }
        else if (type.StartsWith("out "))
        {
            flags |= TypeMarker_Out;
            type = type[4..];
        }

        if (type.EndsWith("?"))
        {
            flags |= TypeMarker_Nullable;
            type = type[..^1];
        }

        if (type.EndsWith("*"))
            flags |= TypeMarker_Pointer;

        return (type, flags);
    }

    string FixupType(string type)
    {
        // Pseudo-syntax for allowing nullable pointer types;
        // not actually supported in C#
        if (type.EndsWith("*?"))
            type = type[..^1];

        return type;
    }

    (string name, string type, string strippedType, int flags)[] parameters = _parameters.Select((p) =>
    {
        var (strippedType, flags) = GetTypeModifiers(p.type);
        return (p.name, FixupType(p.type), strippedType, flags);
    }).ToArray();

    bool isVoid = returnType == "void";
#>

<#
    // Make the generated code look a little nicer if there's no parameters
    if (parameters.Length > 0)
    {
#>
        <#= accessibility #> <#= returnType #> <#= name #>(
            <#= string.Join(",\n            ", parameters.Select((p) => $"{p.type} {p.name}")) #>
        )
<#
    }
    else
    {
#>
        <#= accessibility #> <#= returnType #> <#= name #>()
<#
    }

    var fnPtrParams = parameters.Select((p) =>
    {
        string type = p.strippedType;
        int flags = p.flags;

        if (interfaceTypes.Contains(type) || lightInterfaceTypes.Contains(type))
            type = "IntPtr";

        if ((flags & TypeMarker_In) != 0)
            type = "in " + type;
        else if ((flags & TypeMarker_Out) != 0)
            type = "out " + type;

        return type;
    }).Prepend("IntPtr").Append(returnType);

    var fnCallParams = parameters.Select((p) =>
    {
        string argument = p.name;
        string type = p.strippedType;
        int flags = p.flags;

        if (interfaceTypes.Contains(type) || lightInterfaceTypes.Contains(type))
        {
            if ((flags & TypeMarker_Out) != 0)
                argument = $"IntPtr {p.name}_handle";
            else if ((flags & TypeMarker_Nullable) != 0)
                argument = $"{p.name}?.DangerousGetHandle() ?? IntPtr.Zero";
            else
                argument = $"{p.name}.DangerousGetHandle()";
        }

        if ((flags & TypeMarker_In) != 0)
            argument = "in " + argument;
        else if ((flags & TypeMarker_Out) != 0)
            argument = "out " + argument;

        return argument;
    }).Prepend("thisPtr");

    string fnPtrType = $"delegate* unmanaged[Stdcall]<{string.Join(", ", fnPtrParams)}>";
#>
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");
<#
    foreach (var parameter in parameters)
    {
        string type = parameter.strippedType;
        int flags = parameter.flags;

        // Don't check output or optional parameters
        if ((flags & (TypeMarker_Out | TypeMarker_Nullable)) != 0)
            continue;

        // Verify input handle types
        if (interfaceTypes.Contains(type))
        {
#>
            ThrowHelper.CheckHandle(<#= parameter.name #>);
<#
        }
        else if (lightInterfaceTypes.Contains(type))
        {
#>
            ThrowHelper.CheckDisposed(<#= parameter.name #>.IsInvalid || <#= parameter.name #>.IsClosed, nameof(<#= parameter.name #>));
<#
        }
        // Verify pointer types
        else if ((flags & TypeMarker_Pointer) != 0)
        {
#>
            ThrowHelper.CheckNull(<#= parameter.name #>);
<#
        }
    }
#>

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (<#= fnPtrType #>)vtable[<#= IUnknownMethodCount + methodIndex++ #>];

            <#= !isVoid ? "var result = " : "" #>fnPtr(
                <#= string.Join(",\n                ", fnCallParams) #>
            );

<#
    foreach (var parameter in parameters)
    {
        string type = parameter.strippedType;
        int flags = parameter.flags;

        if (interfaceTypes.Contains(type) || lightInterfaceTypes.Contains(type))
        {
            if ((flags & TypeMarker_Out) != 0)
            {
#>
            <#= parameter.name #> = new(<#= parameter.name #>_handle, ownsHandle: true);
<#
            }
        }
    }

    if (!isVoid)
    {
#>
            return result;
<#
    }
#>
        }
<#
}
#>
namespace SharpGameInput
{
<#
    DefineInterface("IGameInput", () =>
    {
        ForwardMethod("ulong", "GetCurrentTimestamp");

        ForwardMethod("int", "GetCurrentReading", 
            ("GameInputKind", "inputKind"),
            ("IGameInputDevice?", "device"),
            ("out LightIGameInputReading", "reading")
        );
        ForwardMethod("int", "GetNextReading", 
            ("IGameInputReading", "referenceReading"),
            ("GameInputKind", "inputKind"),
            ("IGameInputDevice?", "device"),
            ("out LightIGameInputReading", "reading")
        );
        ForwardMethod("int", "GetPreviousReading",
            ("IGameInputReading", "referenceReading"),
            ("GameInputKind", "inputKind"),
            ("IGameInputDevice?", "device"),
            ("out LightIGameInputReading", "reading")
        );
        ForwardMethod("int", "GetTemporalReading",
            ("ulong", "timestamp"),
            ("IGameInputDevice", "device"),
            ("out LightIGameInputReading", "reading")
        );

        ForwardMethodPrivately("int", "RegisterReadingCallback",
            ("IGameInputDevice?", "device"),
            ("GameInputKind", "inputKind"),
            ("float", "analogThreshold"),
            ("void*?", "context"),
            ("delegate* unmanaged[Stdcall]<ulong, void*, IntPtr, bool, void>",
                "callbackFunc"),
            ("out ulong", "callbackToken")
        );
        ForwardMethodPrivately("int", "RegisterDeviceCallback",
            ("IGameInputDevice?", "device"),
            ("GameInputKind", "inputKind"),
            ("GameInputDeviceStatus", "statusFilter"),
            ("GameInputEnumerationKind", "enumerationKind"),
            ("void*?", "context"),
            ("delegate* unmanaged[Stdcall]<ulong, void*, IntPtr, ulong, GameInputDeviceStatus, GameInputDeviceStatus, void>",
                "callbackFunc"),
            ("out ulong", "callbackToken")
        );
        ForwardMethodPrivately("int", "RegisterGuideButtonCallback",
            ("IGameInputDevice?", "device"),
            ("void*?", "context"),
            ("delegate* unmanaged[Stdcall]<ulong, void*, IntPtr, ulong, bool, void>",
                "callbackFunc"),
            ("out ulong", "callbackToken")
        );
        ForwardMethodPrivately("int", "RegisterKeyboardLayoutCallback",
            ("IGameInputDevice?", "device"),
            ("void*?", "context"),
            ("delegate* unmanaged[Stdcall]<ulong, void*, IntPtr, ulong, uint, uint, void>",
                "callbackFunc"),
            ("out ulong", "callbackToken")
        );
        ForwardMethod("void", "StopCallback",
            ("ulong", "callbackToken")
        );
        ForwardMethodPrivately("bool", "_UnregisterCallback",
            ("ulong", "callbackToken"),
            ("ulong", "timeoutInMicroseconds")
        );

        ForwardMethod("int", "CreateDispatcher",
            ("out IGameInputDispatcher", "dispatcher")
        );
        ForwardMethod("int", "CreateAggregateDevice",
            ("GameInputKind", "inputKind"),
            ("out IGameInputDevice", "device")
        );

        ForwardMethod("int", "FindDeviceFromId",
            ("in APP_LOCAL_DEVICE_ID", "id"),
            ("out IGameInputDevice", "device")
        );
        ForwardMethod("int", "FindDeviceFromObject",
            ("IntPtr", "pUnknown"),
            ("out IGameInputDevice", "device")
        );
        ForwardMethod("int", "FindDeviceFromPlatformHandle",
            ("IntPtr", "handle"),
            ("out IGameInputDevice", "device")
        );
        ForwardMethod("int", "FindDeviceFromPlatformString",
            ("char*", "str"),
            ("out IGameInputDevice", "device")
        );
#>

        public int FindDeviceFromPlatformString(string str, out IGameInputDevice device)
        {
            fixed (char* ptr = str)
                return FindDeviceFromPlatformString(ptr, out device);
        }
<#

        ForwardMethod("int", "EnableOemDeviceSupport",
            ("ushort", "vendorId"),
            ("ushort", "productId"),
            ("byte", "interfaceNumber"),
            ("byte", "collectionNumber")
        );

        ForwardMethod("void", "SetFocusPolicy",
            ("GameInputFocusPolicy", "policy")
        );
    });
#>

<#
    DefineLightInterface("IGameInputReading", () =>
    {
        void MakeArrayWrappers(string returnType, string name, (string type, string name) array)
        {
#>

        public <#= returnType #> <#= name #>(<#= array.type #>[] <#= array.name #>)
        {
            fixed (<#= array.type #>* ptr = <#= array.name #>)
                return <#= name #>((uint)<#= array.name #>.Length, ptr);
        }

        public <#= returnType #> <#= name #>(scoped Span<<#= array.type #>> <#= array.name #>)
        {
            fixed (<#= array.type #>* ptr = <#= array.name #>)
                return <#= name #>((uint)<#= array.name #>.Length, ptr);
        }
<#
        }

        ForwardMethod("GameInputKind", "GetInputKind");
        ForwardMethod("ulong", "GetSequenceNumber",
            ("GameInputKind", "inputKind")
        );
        ForwardMethod("ulong", "GetTimestamp");
        ForwardMethod("void", "GetDevice",
            ("out LightIGameInputDevice", "device")
        );
        ForwardMethod("bool", "GetRawReport",
            ("out LightIGameInputRawDeviceReport", "report")
        );

        ForwardMethod("uint", "GetControllerAxisCount");
        ForwardMethod("uint", "GetControllerAxisState",
            ("uint", "stateArrayCount"),
            ("float*", "stateArray")
        );
        MakeArrayWrappers("uint", "GetControllerAxisState", ("float", "stateArray"));

        ForwardMethod("uint", "GetControllerButtonCount");
        ForwardMethod("uint", "GetControllerButtonState",
            ("uint", "stateArrayCount"),
            ("bool*", "stateArray")
        );
        MakeArrayWrappers("uint", "GetControllerButtonState", ("bool", "stateArray"));

        ForwardMethod("uint", "GetControllerSwitchCount");
        ForwardMethod("uint", "GetControllerSwitchState",
            ("uint", "stateArrayCount"),
            ("GameInputSwitchPosition*", "stateArray")
        );
        MakeArrayWrappers("uint", "GetControllerSwitchState", ("GameInputSwitchPosition", "stateArray"));

        ForwardMethod("uint", "GetKeyCount");
        ForwardMethod("uint", "GetKeyState",
            ("uint", "stateArrayCount"),
            ("GameInputKeyState*", "stateArray")
        );
        MakeArrayWrappers("uint", "GetKeyState", ("GameInputKeyState", "stateArray"));

        ForwardMethod("bool", "GetMouseState",
            ("out GameInputMouseState", "state")
        );

        ForwardMethod("uint", "GetTouchCount");
        ForwardMethod("uint", "GetTouchState",
            ("uint", "stateArrayCount"),
            ("GameInputTouchState*", "stateArray")
        );
        MakeArrayWrappers("uint", "GetTouchState", ("GameInputTouchState", "stateArray"));

        ForwardMethod("bool", "GetMotionState",
            ("out GameInputMotionState", "state")
        );

        ForwardMethod("bool", "GetArcadeStickState",
            ("out GameInputArcadeStickState", "state")
        );

        ForwardMethod("bool", "GetFlightStickState",
            ("out GameInputFlightStickState", "state")
        );

        ForwardMethod("bool", "GetGamepadState",
            ("out GameInputGamepadState", "state")
        );

        ForwardMethod("bool", "GetRacingWheelState",
            ("out GameInputRacingWheelState", "state")
        );

        ForwardMethod("bool", "GetUiNavigationState",
            ("out GameInputUiNavigationState", "state")
        );
    });
#>

<#
    DefineLightInterface("IGameInputDevice", () =>
    {
        ForwardMethodPrivately("GameInputDeviceInfo*", "GetDeviceInfo");
        ForwardMethod("GameInputDeviceStatus", "GetDeviceStatus");
        ForwardMethod("void", "GetBatteryState",
            ("out GameInputBatteryState", "state")
        );

#>

        public ref readonly GameInputDeviceInfo DeviceInfo => ref *GetDeviceInfo();
<#

        ForwardMethod("int", "CreateForceFeedbackEffect",
            ("uint", "motorIndex"),
            ("in GameInputForceFeedbackParams", "ffbParams"),
            ("out LightIGameInputForceFeedbackEffect", "effect")
        );

        ForwardMethod("bool", "IsForceFeedbackMotorPoweredOn",
            ("uint", "motorIndex")
        );

        ForwardMethod("void", "SetForceFeedbackMotorGain",
            ("uint", "motorIndex"),
            ("float", "masterGain")
        );
        ForwardMethod("int", "SetHapticMotorState",
            ("uint", "motorIndex"),
            ("in GameInputHapticFeedbackParams", "hapticParams")
        );
        ForwardMethod("void", "SetRumbleState",
            ("in GameInputRumbleParams", "rumbleParams")
        );

        ForwardMethod("void", "SetInputSynchronizationState",
            ("bool", "enabled")
        );
        ForwardMethod("void", "SendInputSynchronizationHint");

        ForwardMethod("void", "PowerOff");

        ForwardMethod("int", "CreateRawDeviceReport",
            ("uint", "reportId"),
            ("GameInputRawDeviceReportKind", "reportKind"),
            ("out LightIGameInputRawDeviceReport", "report")
        );
        ForwardMethod("int", "GetRawDeviceFeature",
            ("uint", "reportId"),
            ("out LightIGameInputRawDeviceReport", "report")
        );
        ForwardMethod("int", "SetRawDeviceFeature",
            ("LightIGameInputRawDeviceReport", "report")
        );
        ForwardMethod("int", "SendRawDeviceOutput",
            ("LightIGameInputRawDeviceReport", "report")
        );
        ForwardMethod("int", "SendRawDeviceOutputWithResponse",
            ("LightIGameInputRawDeviceReport", "requestReport"),
            ("out LightIGameInputRawDeviceReport", "responseReport")
        );

        ForwardMethod("int", "ExecuteRawDeviceIoControl",
            ("uint", "controlCode"),
            ("nuint", "inputBufferSize"),
            ("void*?", "inputBuffer"),
            ("nuint", "outputBufferSize"),
            ("void*?", "outputBuffer"),
            ("out nuint", "outputSize")
        );
        ForwardMethod("bool", "AcquireExclusiveRawDeviceAccess",
            ("ulong", "timeoutInMicroseconds")
        );
        ForwardMethod("void", "ReleaseExclusiveRawDeviceAccess");
#>

        public int ExecuteRawDeviceIoControl(uint controlCode, byte[] inputBuffer, byte[] outputBuffer,
            out nuint outputSize)
        {
            fixed (byte* inputPtr = inputBuffer)
            fixed (byte* outputPtr = outputBuffer)
                return ExecuteRawDeviceIoControl(controlCode,
                    (nuint)inputBuffer.Length, inputPtr,
                    (nuint)outputBuffer.Length, outputPtr,
                    out outputSize
                );
        }

        public int ExecuteRawDeviceIoControl(uint controlCode,
            scoped ReadOnlySpan<byte> inputBuffer, scoped Span<byte> outputBuffer,
            out nuint outputSize)
        {
            fixed (byte* inputPtr = inputBuffer)
            fixed (byte* outputPtr = outputBuffer)
                return ExecuteRawDeviceIoControl(controlCode,
                    (nuint)inputBuffer.Length, inputPtr,
                    (nuint)outputBuffer.Length, outputPtr,
                    out outputSize
                );
        }

        public int ExecuteRawDeviceIoControl<TIn, TOut>(uint controlCode, in TIn input, out TOut output,
            out nuint outputSize)
            where TIn : unmanaged
            where TOut : unmanaged
        {
            fixed (TIn* inputPtr = &input)
            fixed (TOut* outputPtr = &output)
                return ExecuteRawDeviceIoControl(controlCode,
                    (nuint)sizeof(TIn), inputPtr,
                    (nuint)sizeof(TOut), outputPtr,
                    out outputSize
                );
        }
<#
    });
#>

<#
    DefineInterface("IGameInputDispatcher", () =>
    {
        ForwardMethod("bool", "Dispatch",
            ("ulong", "quotaInMicroseconds")
        );
        ForwardMethod("int", "OpenWaitHandle",
            ("out IntPtr", "waitHandle")
        );
    });
#>

<#
    DefineLightInterface("IGameInputForceFeedbackEffect", () =>
    {
        ForwardMethod("void", "GetDevice",
            ("out LightIGameInputDevice", "device")
        );

        ForwardMethod("uint", "GetMotorIndex");

        ForwardMethod("float", "GetGain");
        ForwardMethod("void", "SetGain",
            ("float", "gain")
        );

        ForwardMethod("void", "GetParams",
            ("out GameInputForceFeedbackParams", "ffbParams")
        );
        ForwardMethod("bool", "SetParams",
            ("in GameInputForceFeedbackParams", "ffbParams")
        );

        ForwardMethod("GameInputFeedbackEffectState", "GetState");
        ForwardMethod("void", "SetState",
            ("GameInputFeedbackEffectState", "state")
        );
    });
#>

<#
    DefineLightInterface("IGameInputRawDeviceReport", () =>
    {
        ForwardMethod("void", "GetDevice",
            ("out LightIGameInputDevice", "device")
        );

        ForwardMethodPrivately("GameInputRawDeviceReportInfo*", "GetReportInfo");

#>

        public ref readonly GameInputRawDeviceReportInfo ReportInfo => ref *GetReportInfo();
<#

        ForwardMethod("nuint", "GetRawDataSize");
        ForwardMethod("nuint", "GetRawData",
            ("nuint", "bufferSize"),
            ("void*", "buffer")
        );
        ForwardMethod("bool", "SetRawData",
            ("nuint", "bufferSize"),
            ("void*", "buffer")
        );

#>

        public nuint GetRawData(byte[] buffer)
        {
            fixed (byte* ptr = buffer)
                return GetRawData((nuint)buffer.Length, ptr);
        }

        public nuint GetRawData(scoped Span<byte> buffer)
        {
            fixed (byte* ptr = buffer)
                return GetRawData((nuint)buffer.Length, ptr);
        }

        public nuint GetRawData<T>(out T data)
            where T : unmanaged
        {
            fixed (T* ptr = &data)
                return GetRawData((nuint)sizeof(T), ptr);
        }

        public bool SetRawData(byte[] buffer)
        {
            fixed (byte* ptr = buffer)
                return SetRawData((nuint)buffer.Length, ptr);
        }

        public bool SetRawData(scoped ReadOnlySpan<byte> buffer)
        {
            fixed (byte* ptr = buffer)
                return SetRawData((nuint)buffer.Length, ptr);
        }

        public bool SetRawData<T>(in T data)
            where T : unmanaged
        {
            fixed (T* ptr = &data)
                return SetRawData((nuint)sizeof(T), ptr);
        }
<#

        ForwardMethod("bool", "GetItemValue",
            ("uint", "itemIndex"),
            ("out long", "value")
        );
        ForwardMethod("bool", "SetItemValue",
            ("uint", "itemIndex"),
            ("long", "value")
        );

        ForwardMethod("bool", "ResetItemValue",
            ("uint", "itemIndex")
        );
        ForwardMethod("bool", "ResetAllItems");
    });
#>
}