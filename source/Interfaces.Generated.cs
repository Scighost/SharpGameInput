//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;

#nullable enable

namespace SharpGameInput
{
    public sealed unsafe partial class IGameInput : SafeHandle
    {
        public override bool IsInvalid => handle == IntPtr.Zero;

        internal IGameInput(IntPtr handle, bool ownsHandle)
            : base(IntPtr.Zero, ownsHandle)
        {
            SetHandle(handle);
        }

        protected override bool ReleaseHandle()
        {
            return Marshal.Release(handle) >= 0;
        }

        public ulong GetCurrentTimestamp()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, ulong>)vtable[3];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public int GetCurrentReading(
            GameInputKind inputKind,
            IGameInputDevice? device,
            out LightIGameInputReading reading
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputKind, IntPtr, out IntPtr, int>)vtable[4];

            var result = fnPtr(
                thisPtr,
                inputKind,
                device?.DangerousGetHandle() ?? IntPtr.Zero,
                out IntPtr reading_handle
            );

            reading = new(reading_handle, ownsHandle: true);
            return result;
        }

        public int GetNextReading(
            IGameInputReading referenceReading,
            GameInputKind inputKind,
            IGameInputDevice? device,
            out LightIGameInputReading reading
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");
            ThrowHelper.CheckHandle(referenceReading);

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, GameInputKind, IntPtr, out IntPtr, int>)vtable[5];

            var result = fnPtr(
                thisPtr,
                referenceReading.DangerousGetHandle(),
                inputKind,
                device?.DangerousGetHandle() ?? IntPtr.Zero,
                out IntPtr reading_handle
            );

            reading = new(reading_handle, ownsHandle: true);
            return result;
        }

        public int GetPreviousReading(
            IGameInputReading referenceReading,
            GameInputKind inputKind,
            IGameInputDevice? device,
            out LightIGameInputReading reading
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");
            ThrowHelper.CheckHandle(referenceReading);

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, GameInputKind, IntPtr, out IntPtr, int>)vtable[6];

            var result = fnPtr(
                thisPtr,
                referenceReading.DangerousGetHandle(),
                inputKind,
                device?.DangerousGetHandle() ?? IntPtr.Zero,
                out IntPtr reading_handle
            );

            reading = new(reading_handle, ownsHandle: true);
            return result;
        }

        public int GetTemporalReading(
            ulong timestamp,
            IGameInputDevice device,
            out LightIGameInputReading reading
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");
            ThrowHelper.CheckHandle(device);

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, ulong, IntPtr, out IntPtr, int>)vtable[7];

            var result = fnPtr(
                thisPtr,
                timestamp,
                device.DangerousGetHandle(),
                out IntPtr reading_handle
            );

            reading = new(reading_handle, ownsHandle: true);
            return result;
        }

        public int RegisterReadingCallback(
            IGameInputDevice? device,
            GameInputKind inputKind,
            float analogThreshold,
            void* context,
            delegate* unmanaged[Stdcall]<ulong, void*, IntPtr, bool, void> callbackFunc,
            out ulong callbackToken
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, GameInputKind, float, void*, delegate* unmanaged[Stdcall]<ulong, void*, IntPtr, bool, void>, out ulong, int>)vtable[8];

            var result = fnPtr(
                thisPtr,
                device?.DangerousGetHandle() ?? IntPtr.Zero,
                inputKind,
                analogThreshold,
                context,
                callbackFunc,
                out callbackToken
            );

            return result;
        }

        public int RegisterDeviceCallback(
            IGameInputDevice? device,
            GameInputKind inputKind,
            GameInputDeviceStatus statusFilter,
            GameInputEnumerationKind enumerationKind,
            void* context,
            delegate* unmanaged[Stdcall]<ulong, void*, IntPtr, ulong, GameInputDeviceStatus, GameInputDeviceStatus, void> callbackFunc,
            out ulong callbackToken
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, GameInputKind, GameInputDeviceStatus, GameInputEnumerationKind, void*, delegate* unmanaged[Stdcall]<ulong, void*, IntPtr, ulong, GameInputDeviceStatus, GameInputDeviceStatus, void>, out ulong, int>)vtable[9];

            var result = fnPtr(
                thisPtr,
                device?.DangerousGetHandle() ?? IntPtr.Zero,
                inputKind,
                statusFilter,
                enumerationKind,
                context,
                callbackFunc,
                out callbackToken
            );

            return result;
        }

        public int RegisterGuideButtonCallback(
            IGameInputDevice? device,
            void* context,
            delegate* unmanaged[Stdcall]<ulong, void*, IntPtr, ulong, bool, void> callbackFunc,
            out ulong callbackToken
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, void*, delegate* unmanaged[Stdcall]<ulong, void*, IntPtr, ulong, bool, void>, out ulong, int>)vtable[10];

            var result = fnPtr(
                thisPtr,
                device?.DangerousGetHandle() ?? IntPtr.Zero,
                context,
                callbackFunc,
                out callbackToken
            );

            return result;
        }

        public int RegisterKeyboardLayoutCallback(
            IGameInputDevice? device,
            void* context,
            delegate* unmanaged[Stdcall]<ulong, void*, IntPtr, ulong, uint, uint, void> callbackFunc,
            out ulong callbackToken
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, void*, delegate* unmanaged[Stdcall]<ulong, void*, IntPtr, ulong, uint, uint, void>, out ulong, int>)vtable[11];

            var result = fnPtr(
                thisPtr,
                device?.DangerousGetHandle() ?? IntPtr.Zero,
                context,
                callbackFunc,
                out callbackToken
            );

            return result;
        }

        public void StopCallback(
            ulong callbackToken
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, ulong, void>)vtable[12];

            fnPtr(
                thisPtr,
                callbackToken
            );

        }

        public bool UnregisterCallback(
            ulong callbackToken,
            ulong timeoutInMicroseconds
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, ulong, ulong, bool>)vtable[13];

            var result = fnPtr(
                thisPtr,
                callbackToken,
                timeoutInMicroseconds
            );

            return result;
        }

        public int CreateDispatcher(
            out IGameInputDispatcher dispatcher
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>)vtable[14];

            var result = fnPtr(
                thisPtr,
                out IntPtr dispatcher_handle
            );

            dispatcher = new(dispatcher_handle, ownsHandle: true);
            return result;
        }

        public int CreateAggregateDevice(
            GameInputKind inputKind,
            out IGameInputDevice device
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputKind, out IntPtr, int>)vtable[15];

            var result = fnPtr(
                thisPtr,
                inputKind,
                out IntPtr device_handle
            );

            device = new(device_handle, ownsHandle: true);
            return result;
        }

        public int FindDeviceFromId(
            in APP_LOCAL_DEVICE_ID id,
            out IGameInputDevice device
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, in APP_LOCAL_DEVICE_ID, out IntPtr, int>)vtable[16];

            var result = fnPtr(
                thisPtr,
                in id,
                out IntPtr device_handle
            );

            device = new(device_handle, ownsHandle: true);
            return result;
        }

        public int FindDeviceFromObject(
            IntPtr pUnknown,
            out IGameInputDevice device
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>)vtable[17];

            var result = fnPtr(
                thisPtr,
                pUnknown,
                out IntPtr device_handle
            );

            device = new(device_handle, ownsHandle: true);
            return result;
        }

        public int FindDeviceFromPlatformHandle(
            IntPtr handle,
            out IGameInputDevice device
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>)vtable[18];

            var result = fnPtr(
                thisPtr,
                handle,
                out IntPtr device_handle
            );

            device = new(device_handle, ownsHandle: true);
            return result;
        }

        public int FindDeviceFromPlatformString(
            char* str,
            out IGameInputDevice device
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, char*, out IntPtr, int>)vtable[19];

            var result = fnPtr(
                thisPtr,
                str,
                out IntPtr device_handle
            );

            device = new(device_handle, ownsHandle: true);
            return result;
        }

        public int FindDeviceFromPlatformString(string str, out IGameInputDevice device)
        {
            fixed (char* ptr = str)
                return FindDeviceFromPlatformString(ptr, out device);
        }

        public int EnableOemDeviceSupport(
            ushort vendorId,
            ushort productId,
            byte interfaceNumber,
            byte collectionNumber
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, ushort, ushort, byte, byte, int>)vtable[20];

            var result = fnPtr(
                thisPtr,
                vendorId,
                productId,
                interfaceNumber,
                collectionNumber
            );

            return result;
        }

        public void SetFocusPolicy(
            GameInputFocusPolicy policy
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputFocusPolicy, void>)vtable[21];

            fnPtr(
                thisPtr,
                policy
            );

        }
    }

    public sealed unsafe partial class IGameInputReading : SafeHandle
    {
        public override bool IsInvalid => handle == IntPtr.Zero;

        internal IGameInputReading(IntPtr handle, bool ownsHandle)
            : base(IntPtr.Zero, ownsHandle)
        {
            SetHandle(handle);
        }

        protected override bool ReleaseHandle()
        {
            return Marshal.Release(handle) >= 0;
        }

        public GameInputKind GetInputKind()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputKind>)vtable[3];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public ulong GetSequenceNumber(
            GameInputKind inputKind
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputKind, ulong>)vtable[4];

            var result = fnPtr(
                thisPtr,
                inputKind
            );

            return result;
        }

        public ulong GetTimestamp()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, ulong>)vtable[5];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public void GetDevice(
            out LightIGameInputDevice device
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, void>)vtable[6];

            fnPtr(
                thisPtr,
                out IntPtr device_handle
            );

            device = new(device_handle, ownsHandle: true);
        }

        public bool GetRawReport(
            out LightIGameInputRawDeviceReport report
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, bool>)vtable[7];

            var result = fnPtr(
                thisPtr,
                out IntPtr report_handle
            );

            report = new(report_handle, ownsHandle: true);
            return result;
        }

        public uint GetControllerAxisCount()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint>)vtable[8];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public uint GetControllerAxisState(
            uint stateArrayCount,
            float* stateArray
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, float*, uint>)vtable[9];

            var result = fnPtr(
                thisPtr,
                stateArrayCount,
                stateArray
            );

            return result;
        }

        public uint GetControllerAxisState(float[] stateArray)
        {
            fixed (float* ptr = stateArray)
                return GetControllerAxisState((uint)stateArray.Length, ptr);
        }

        public uint GetControllerAxisState(Span<float> stateArray)
        {
            fixed (float* ptr = stateArray)
                return GetControllerAxisState((uint)stateArray.Length, ptr);
        }

        public uint GetControllerButtonCount()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint>)vtable[10];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public uint GetControllerButtonState(
            uint stateArrayCount,
            bool* stateArray
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, bool*, uint>)vtable[11];

            var result = fnPtr(
                thisPtr,
                stateArrayCount,
                stateArray
            );

            return result;
        }

        public uint GetControllerButtonState(bool[] stateArray)
        {
            fixed (bool* ptr = stateArray)
                return GetControllerButtonState((uint)stateArray.Length, ptr);
        }

        public uint GetControllerButtonState(Span<bool> stateArray)
        {
            fixed (bool* ptr = stateArray)
                return GetControllerButtonState((uint)stateArray.Length, ptr);
        }

        public uint GetControllerSwitchCount()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint>)vtable[12];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public uint GetControllerSwitchState(
            uint stateArrayCount,
            GameInputSwitchPosition* stateArray
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, GameInputSwitchPosition*, uint>)vtable[13];

            var result = fnPtr(
                thisPtr,
                stateArrayCount,
                stateArray
            );

            return result;
        }

        public uint GetControllerSwitchState(GameInputSwitchPosition[] stateArray)
        {
            fixed (GameInputSwitchPosition* ptr = stateArray)
                return GetControllerSwitchState((uint)stateArray.Length, ptr);
        }

        public uint GetControllerSwitchState(Span<GameInputSwitchPosition> stateArray)
        {
            fixed (GameInputSwitchPosition* ptr = stateArray)
                return GetControllerSwitchState((uint)stateArray.Length, ptr);
        }

        public uint GetKeyCount()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint>)vtable[14];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public uint GetKeyState(
            uint stateArrayCount,
            GameInputKeyState* stateArray
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, GameInputKeyState*, uint>)vtable[15];

            var result = fnPtr(
                thisPtr,
                stateArrayCount,
                stateArray
            );

            return result;
        }

        public uint GetKeyState(GameInputKeyState[] stateArray)
        {
            fixed (GameInputKeyState* ptr = stateArray)
                return GetKeyState((uint)stateArray.Length, ptr);
        }

        public uint GetKeyState(Span<GameInputKeyState> stateArray)
        {
            fixed (GameInputKeyState* ptr = stateArray)
                return GetKeyState((uint)stateArray.Length, ptr);
        }

        public bool GetMouseState(
            out GameInputMouseState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputMouseState, bool>)vtable[16];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }

        public uint GetTouchCount()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint>)vtable[17];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public uint GetTouchState(
            uint stateArrayCount,
            GameInputTouchState* stateArray
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, GameInputTouchState*, uint>)vtable[18];

            var result = fnPtr(
                thisPtr,
                stateArrayCount,
                stateArray
            );

            return result;
        }

        public uint GetTouchState(GameInputTouchState[] stateArray)
        {
            fixed (GameInputTouchState* ptr = stateArray)
                return GetTouchState((uint)stateArray.Length, ptr);
        }

        public uint GetTouchState(Span<GameInputTouchState> stateArray)
        {
            fixed (GameInputTouchState* ptr = stateArray)
                return GetTouchState((uint)stateArray.Length, ptr);
        }

        public bool GetMotionState(
            out GameInputMotionState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputMotionState, bool>)vtable[19];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }

        public bool GetArcadeStickState(
            out GameInputArcadeStickState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputArcadeStickState, bool>)vtable[20];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }

        public bool GetFlightStickState(
            out GameInputFlightStickState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputFlightStickState, bool>)vtable[21];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }

        public bool GetGamepadState(
            out GameInputGamepadState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputGamepadState, bool>)vtable[22];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }

        public bool GetRacingWheelState(
            out GameInputRacingWheelState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputRacingWheelState, bool>)vtable[23];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }

        public bool GetUiNavigationState(
            out GameInputUiNavigationState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputUiNavigationState, bool>)vtable[24];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }
    }

    public unsafe ref partial struct LightIGameInputReading
    {
        private IntPtr handle;
        private bool ownsHandle;

        public bool IsInvalid => handle == IntPtr.Zero;
        public bool IsClosed { get; private set; }

        internal LightIGameInputReading(IntPtr handle, bool ownsHandle)
        {
            this.handle = handle;
            this.ownsHandle = ownsHandle;
            IsClosed = false;
        }

        public void Dispose()
        {
            if (!IsClosed && !IsInvalid && ownsHandle)
            {
                Marshal.Release(handle);
                IsClosed = true;
            }
        }

        public IntPtr DangerousGetHandle() => handle;

        public IGameInputReading ToSafeHandle()
        {
            // Invalidate this handle
            IsClosed = true;

            // Move handle to the new instance
            var handle = this.handle;
            this.handle = IntPtr.Zero;
            return new(handle, ownsHandle);
        }

        public static implicit operator LightIGameInputReading(IGameInputReading instance)
        {
            return new(instance.DangerousGetHandle(), ownsHandle: false);
        }

        public GameInputKind GetInputKind()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputKind>)vtable[3];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public ulong GetSequenceNumber(
            GameInputKind inputKind
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputKind, ulong>)vtable[4];

            var result = fnPtr(
                thisPtr,
                inputKind
            );

            return result;
        }

        public ulong GetTimestamp()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, ulong>)vtable[5];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public void GetDevice(
            out LightIGameInputDevice device
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, void>)vtable[6];

            fnPtr(
                thisPtr,
                out IntPtr device_handle
            );

            device = new(device_handle, ownsHandle: true);
        }

        public bool GetRawReport(
            out LightIGameInputRawDeviceReport report
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, bool>)vtable[7];

            var result = fnPtr(
                thisPtr,
                out IntPtr report_handle
            );

            report = new(report_handle, ownsHandle: true);
            return result;
        }

        public uint GetControllerAxisCount()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint>)vtable[8];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public uint GetControllerAxisState(
            uint stateArrayCount,
            float* stateArray
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, float*, uint>)vtable[9];

            var result = fnPtr(
                thisPtr,
                stateArrayCount,
                stateArray
            );

            return result;
        }

        public uint GetControllerAxisState(float[] stateArray)
        {
            fixed (float* ptr = stateArray)
                return GetControllerAxisState((uint)stateArray.Length, ptr);
        }

        public uint GetControllerAxisState(Span<float> stateArray)
        {
            fixed (float* ptr = stateArray)
                return GetControllerAxisState((uint)stateArray.Length, ptr);
        }

        public uint GetControllerButtonCount()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint>)vtable[10];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public uint GetControllerButtonState(
            uint stateArrayCount,
            bool* stateArray
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, bool*, uint>)vtable[11];

            var result = fnPtr(
                thisPtr,
                stateArrayCount,
                stateArray
            );

            return result;
        }

        public uint GetControllerButtonState(bool[] stateArray)
        {
            fixed (bool* ptr = stateArray)
                return GetControllerButtonState((uint)stateArray.Length, ptr);
        }

        public uint GetControllerButtonState(Span<bool> stateArray)
        {
            fixed (bool* ptr = stateArray)
                return GetControllerButtonState((uint)stateArray.Length, ptr);
        }

        public uint GetControllerSwitchCount()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint>)vtable[12];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public uint GetControllerSwitchState(
            uint stateArrayCount,
            GameInputSwitchPosition* stateArray
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, GameInputSwitchPosition*, uint>)vtable[13];

            var result = fnPtr(
                thisPtr,
                stateArrayCount,
                stateArray
            );

            return result;
        }

        public uint GetControllerSwitchState(GameInputSwitchPosition[] stateArray)
        {
            fixed (GameInputSwitchPosition* ptr = stateArray)
                return GetControllerSwitchState((uint)stateArray.Length, ptr);
        }

        public uint GetControllerSwitchState(Span<GameInputSwitchPosition> stateArray)
        {
            fixed (GameInputSwitchPosition* ptr = stateArray)
                return GetControllerSwitchState((uint)stateArray.Length, ptr);
        }

        public uint GetKeyCount()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint>)vtable[14];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public uint GetKeyState(
            uint stateArrayCount,
            GameInputKeyState* stateArray
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, GameInputKeyState*, uint>)vtable[15];

            var result = fnPtr(
                thisPtr,
                stateArrayCount,
                stateArray
            );

            return result;
        }

        public uint GetKeyState(GameInputKeyState[] stateArray)
        {
            fixed (GameInputKeyState* ptr = stateArray)
                return GetKeyState((uint)stateArray.Length, ptr);
        }

        public uint GetKeyState(Span<GameInputKeyState> stateArray)
        {
            fixed (GameInputKeyState* ptr = stateArray)
                return GetKeyState((uint)stateArray.Length, ptr);
        }

        public bool GetMouseState(
            out GameInputMouseState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputMouseState, bool>)vtable[16];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }

        public uint GetTouchCount()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint>)vtable[17];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public uint GetTouchState(
            uint stateArrayCount,
            GameInputTouchState* stateArray
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, GameInputTouchState*, uint>)vtable[18];

            var result = fnPtr(
                thisPtr,
                stateArrayCount,
                stateArray
            );

            return result;
        }

        public uint GetTouchState(GameInputTouchState[] stateArray)
        {
            fixed (GameInputTouchState* ptr = stateArray)
                return GetTouchState((uint)stateArray.Length, ptr);
        }

        public uint GetTouchState(Span<GameInputTouchState> stateArray)
        {
            fixed (GameInputTouchState* ptr = stateArray)
                return GetTouchState((uint)stateArray.Length, ptr);
        }

        public bool GetMotionState(
            out GameInputMotionState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputMotionState, bool>)vtable[19];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }

        public bool GetArcadeStickState(
            out GameInputArcadeStickState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputArcadeStickState, bool>)vtable[20];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }

        public bool GetFlightStickState(
            out GameInputFlightStickState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputFlightStickState, bool>)vtable[21];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }

        public bool GetGamepadState(
            out GameInputGamepadState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputGamepadState, bool>)vtable[22];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }

        public bool GetRacingWheelState(
            out GameInputRacingWheelState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputRacingWheelState, bool>)vtable[23];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }

        public bool GetUiNavigationState(
            out GameInputUiNavigationState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputUiNavigationState, bool>)vtable[24];

            var result = fnPtr(
                thisPtr,
                out state
            );

            return result;
        }
    }

    public sealed unsafe partial class IGameInputDevice : SafeHandle
    {
        public override bool IsInvalid => handle == IntPtr.Zero;

        internal IGameInputDevice(IntPtr handle, bool ownsHandle)
            : base(IntPtr.Zero, ownsHandle)
        {
            SetHandle(handle);
        }

        protected override bool ReleaseHandle()
        {
            return Marshal.Release(handle) >= 0;
        }

        public GameInputDeviceInfo* GetDeviceInfo()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputDeviceInfo*>)vtable[3];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public GameInputDeviceStatus GetDeviceStatus()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputDeviceStatus>)vtable[4];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public void GetBatteryState(
            out GameInputBatteryState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputBatteryState, void>)vtable[5];

            fnPtr(
                thisPtr,
                out state
            );

        }

        public ref readonly GameInputDeviceInfo DeviceInfo => ref *GetDeviceInfo();

        public int CreateForceFeedbackEffect(
            uint motorIndex,
            in GameInputForceFeedbackParams ffbParams,
            out LightIGameInputForceFeedbackEffect effect
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, in GameInputForceFeedbackParams, out IntPtr, int>)vtable[6];

            var result = fnPtr(
                thisPtr,
                motorIndex,
                in ffbParams,
                out IntPtr effect_handle
            );

            effect = new(effect_handle, ownsHandle: true);
            return result;
        }

        public bool IsForceFeedbackMotorPoweredOn(
            uint motorIndex
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, bool>)vtable[7];

            var result = fnPtr(
                thisPtr,
                motorIndex
            );

            return result;
        }

        public void SetForceFeedbackMotorGain(
            uint motorIndex,
            float masterGain
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, float, void>)vtable[8];

            fnPtr(
                thisPtr,
                motorIndex,
                masterGain
            );

        }

        public int SetHapticMotorState(
            uint motorIndex,
            in GameInputHapticFeedbackParams hapticParams
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, in GameInputHapticFeedbackParams, int>)vtable[9];

            var result = fnPtr(
                thisPtr,
                motorIndex,
                in hapticParams
            );

            return result;
        }

        public void SetRumbleState(
            in GameInputRumbleParams rumbleParams
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, in GameInputRumbleParams, void>)vtable[10];

            fnPtr(
                thisPtr,
                in rumbleParams
            );

        }

        public void SetInputSynchronizationState(
            bool enabled
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, bool, void>)vtable[11];

            fnPtr(
                thisPtr,
                enabled
            );

        }

        public void SendInputSynchronizationHint()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, void>)vtable[12];

            fnPtr(
                thisPtr
            );

        }

        public void PowerOff()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, void>)vtable[13];

            fnPtr(
                thisPtr
            );

        }

        public int CreateRawDeviceReport(
            uint reportId,
            GameInputRawDeviceReportKind reportKind,
            out LightIGameInputRawDeviceReport report
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, GameInputRawDeviceReportKind, out IntPtr, int>)vtable[14];

            var result = fnPtr(
                thisPtr,
                reportId,
                reportKind,
                out IntPtr report_handle
            );

            report = new(report_handle, ownsHandle: true);
            return result;
        }

        public int GetRawDeviceFeature(
            uint reportId,
            out LightIGameInputRawDeviceReport report
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, out IntPtr, int>)vtable[15];

            var result = fnPtr(
                thisPtr,
                reportId,
                out IntPtr report_handle
            );

            report = new(report_handle, ownsHandle: true);
            return result;
        }

        public int SetRawDeviceFeature(
            LightIGameInputRawDeviceReport report
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");
            ThrowHelper.CheckDisposed(report.IsInvalid || report.IsClosed, nameof(report));

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)vtable[16];

            var result = fnPtr(
                thisPtr,
                report.DangerousGetHandle()
            );

            return result;
        }

        public int SendRawDeviceOutput(
            LightIGameInputRawDeviceReport report
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");
            ThrowHelper.CheckDisposed(report.IsInvalid || report.IsClosed, nameof(report));

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)vtable[17];

            var result = fnPtr(
                thisPtr,
                report.DangerousGetHandle()
            );

            return result;
        }

        public int SendRawDeviceOutputWithResponse(
            LightIGameInputRawDeviceReport requestReport,
            out LightIGameInputRawDeviceReport responseReport
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");
            ThrowHelper.CheckDisposed(requestReport.IsInvalid || requestReport.IsClosed, nameof(requestReport));

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>)vtable[18];

            var result = fnPtr(
                thisPtr,
                requestReport.DangerousGetHandle(),
                out IntPtr responseReport_handle
            );

            responseReport = new(responseReport_handle, ownsHandle: true);
            return result;
        }

        public int ExecuteRawDeviceIoControl(
            uint controlCode,
            nuint inputBufferSize,
            void* inputBuffer,
            nuint outputBufferSize,
            void* outputBuffer,
            out nuint outputSize
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, nuint, void*, nuint, void*, out nuint, int>)vtable[19];

            var result = fnPtr(
                thisPtr,
                controlCode,
                inputBufferSize,
                inputBuffer,
                outputBufferSize,
                outputBuffer,
                out outputSize
            );

            return result;
        }

        public bool AcquireExclusiveRawDeviceAccess(
            ulong timeoutInMicroseconds
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, ulong, bool>)vtable[20];

            var result = fnPtr(
                thisPtr,
                timeoutInMicroseconds
            );

            return result;
        }

        public void ReleaseExclusiveRawDeviceAccess()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, void>)vtable[21];

            fnPtr(
                thisPtr
            );

        }

        public int ExecuteRawDeviceIoControl(uint controlCode, byte[] inputBuffer, byte[] outputBuffer,
            out nuint outputSize)
        {
            fixed (byte* inputPtr = inputBuffer)
            fixed (byte* outputPtr = outputBuffer)
                return ExecuteRawDeviceIoControl(controlCode,
                    (nuint)inputBuffer.Length, inputPtr,
                    (nuint)outputBuffer.Length, outputPtr,
                    out outputSize
                );
        }

        public int ExecuteRawDeviceIoControl(uint controlCode, ReadOnlySpan<byte> inputBuffer, Span<byte> outputBuffer,
            out nuint outputSize)
        {
            fixed (byte* inputPtr = inputBuffer)
            fixed (byte* outputPtr = outputBuffer)
                return ExecuteRawDeviceIoControl(controlCode,
                    (nuint)inputBuffer.Length, inputPtr,
                    (nuint)outputBuffer.Length, outputPtr,
                    out outputSize
                );
        }

        public int ExecuteRawDeviceIoControl<TIn, TOut>(uint controlCode, in TIn input, out TOut output,
            out nuint outputSize)
            where TIn : unmanaged
            where TOut : unmanaged
        {
            fixed (TIn* inputPtr = &input)
            fixed (TOut* outputPtr = &output)
                return ExecuteRawDeviceIoControl(controlCode,
                    (nuint)sizeof(TIn), inputPtr,
                    (nuint)sizeof(TOut), outputPtr,
                    out outputSize
                );
        }
    }

    public unsafe ref partial struct LightIGameInputDevice
    {
        private IntPtr handle;
        private bool ownsHandle;

        public bool IsInvalid => handle == IntPtr.Zero;
        public bool IsClosed { get; private set; }

        internal LightIGameInputDevice(IntPtr handle, bool ownsHandle)
        {
            this.handle = handle;
            this.ownsHandle = ownsHandle;
            IsClosed = false;
        }

        public void Dispose()
        {
            if (!IsClosed && !IsInvalid && ownsHandle)
            {
                Marshal.Release(handle);
                IsClosed = true;
            }
        }

        public IntPtr DangerousGetHandle() => handle;

        public IGameInputDevice ToSafeHandle()
        {
            // Invalidate this handle
            IsClosed = true;

            // Move handle to the new instance
            var handle = this.handle;
            this.handle = IntPtr.Zero;
            return new(handle, ownsHandle);
        }

        public static implicit operator LightIGameInputDevice(IGameInputDevice instance)
        {
            return new(instance.DangerousGetHandle(), ownsHandle: false);
        }

        public GameInputDeviceInfo* GetDeviceInfo()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputDeviceInfo*>)vtable[3];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public GameInputDeviceStatus GetDeviceStatus()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputDeviceStatus>)vtable[4];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public void GetBatteryState(
            out GameInputBatteryState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputBatteryState, void>)vtable[5];

            fnPtr(
                thisPtr,
                out state
            );

        }

        public ref readonly GameInputDeviceInfo DeviceInfo => ref *GetDeviceInfo();

        public int CreateForceFeedbackEffect(
            uint motorIndex,
            in GameInputForceFeedbackParams ffbParams,
            out LightIGameInputForceFeedbackEffect effect
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, in GameInputForceFeedbackParams, out IntPtr, int>)vtable[6];

            var result = fnPtr(
                thisPtr,
                motorIndex,
                in ffbParams,
                out IntPtr effect_handle
            );

            effect = new(effect_handle, ownsHandle: true);
            return result;
        }

        public bool IsForceFeedbackMotorPoweredOn(
            uint motorIndex
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, bool>)vtable[7];

            var result = fnPtr(
                thisPtr,
                motorIndex
            );

            return result;
        }

        public void SetForceFeedbackMotorGain(
            uint motorIndex,
            float masterGain
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, float, void>)vtable[8];

            fnPtr(
                thisPtr,
                motorIndex,
                masterGain
            );

        }

        public int SetHapticMotorState(
            uint motorIndex,
            in GameInputHapticFeedbackParams hapticParams
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, in GameInputHapticFeedbackParams, int>)vtable[9];

            var result = fnPtr(
                thisPtr,
                motorIndex,
                in hapticParams
            );

            return result;
        }

        public void SetRumbleState(
            in GameInputRumbleParams rumbleParams
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, in GameInputRumbleParams, void>)vtable[10];

            fnPtr(
                thisPtr,
                in rumbleParams
            );

        }

        public void SetInputSynchronizationState(
            bool enabled
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, bool, void>)vtable[11];

            fnPtr(
                thisPtr,
                enabled
            );

        }

        public void SendInputSynchronizationHint()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, void>)vtable[12];

            fnPtr(
                thisPtr
            );

        }

        public void PowerOff()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, void>)vtable[13];

            fnPtr(
                thisPtr
            );

        }

        public int CreateRawDeviceReport(
            uint reportId,
            GameInputRawDeviceReportKind reportKind,
            out LightIGameInputRawDeviceReport report
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, GameInputRawDeviceReportKind, out IntPtr, int>)vtable[14];

            var result = fnPtr(
                thisPtr,
                reportId,
                reportKind,
                out IntPtr report_handle
            );

            report = new(report_handle, ownsHandle: true);
            return result;
        }

        public int GetRawDeviceFeature(
            uint reportId,
            out LightIGameInputRawDeviceReport report
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, out IntPtr, int>)vtable[15];

            var result = fnPtr(
                thisPtr,
                reportId,
                out IntPtr report_handle
            );

            report = new(report_handle, ownsHandle: true);
            return result;
        }

        public int SetRawDeviceFeature(
            LightIGameInputRawDeviceReport report
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");
            ThrowHelper.CheckDisposed(report.IsInvalid || report.IsClosed, nameof(report));

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)vtable[16];

            var result = fnPtr(
                thisPtr,
                report.DangerousGetHandle()
            );

            return result;
        }

        public int SendRawDeviceOutput(
            LightIGameInputRawDeviceReport report
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");
            ThrowHelper.CheckDisposed(report.IsInvalid || report.IsClosed, nameof(report));

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>)vtable[17];

            var result = fnPtr(
                thisPtr,
                report.DangerousGetHandle()
            );

            return result;
        }

        public int SendRawDeviceOutputWithResponse(
            LightIGameInputRawDeviceReport requestReport,
            out LightIGameInputRawDeviceReport responseReport
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");
            ThrowHelper.CheckDisposed(requestReport.IsInvalid || requestReport.IsClosed, nameof(requestReport));

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, out IntPtr, int>)vtable[18];

            var result = fnPtr(
                thisPtr,
                requestReport.DangerousGetHandle(),
                out IntPtr responseReport_handle
            );

            responseReport = new(responseReport_handle, ownsHandle: true);
            return result;
        }

        public int ExecuteRawDeviceIoControl(
            uint controlCode,
            nuint inputBufferSize,
            void* inputBuffer,
            nuint outputBufferSize,
            void* outputBuffer,
            out nuint outputSize
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, nuint, void*, nuint, void*, out nuint, int>)vtable[19];

            var result = fnPtr(
                thisPtr,
                controlCode,
                inputBufferSize,
                inputBuffer,
                outputBufferSize,
                outputBuffer,
                out outputSize
            );

            return result;
        }

        public bool AcquireExclusiveRawDeviceAccess(
            ulong timeoutInMicroseconds
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, ulong, bool>)vtable[20];

            var result = fnPtr(
                thisPtr,
                timeoutInMicroseconds
            );

            return result;
        }

        public void ReleaseExclusiveRawDeviceAccess()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, void>)vtable[21];

            fnPtr(
                thisPtr
            );

        }

        public int ExecuteRawDeviceIoControl(uint controlCode, byte[] inputBuffer, byte[] outputBuffer,
            out nuint outputSize)
        {
            fixed (byte* inputPtr = inputBuffer)
            fixed (byte* outputPtr = outputBuffer)
                return ExecuteRawDeviceIoControl(controlCode,
                    (nuint)inputBuffer.Length, inputPtr,
                    (nuint)outputBuffer.Length, outputPtr,
                    out outputSize
                );
        }

        public int ExecuteRawDeviceIoControl(uint controlCode, ReadOnlySpan<byte> inputBuffer, Span<byte> outputBuffer,
            out nuint outputSize)
        {
            fixed (byte* inputPtr = inputBuffer)
            fixed (byte* outputPtr = outputBuffer)
                return ExecuteRawDeviceIoControl(controlCode,
                    (nuint)inputBuffer.Length, inputPtr,
                    (nuint)outputBuffer.Length, outputPtr,
                    out outputSize
                );
        }

        public int ExecuteRawDeviceIoControl<TIn, TOut>(uint controlCode, in TIn input, out TOut output,
            out nuint outputSize)
            where TIn : unmanaged
            where TOut : unmanaged
        {
            fixed (TIn* inputPtr = &input)
            fixed (TOut* outputPtr = &output)
                return ExecuteRawDeviceIoControl(controlCode,
                    (nuint)sizeof(TIn), inputPtr,
                    (nuint)sizeof(TOut), outputPtr,
                    out outputSize
                );
        }
    }

    public sealed unsafe partial class IGameInputDispatcher : SafeHandle
    {
        public override bool IsInvalid => handle == IntPtr.Zero;

        internal IGameInputDispatcher(IntPtr handle, bool ownsHandle)
            : base(IntPtr.Zero, ownsHandle)
        {
            SetHandle(handle);
        }

        protected override bool ReleaseHandle()
        {
            return Marshal.Release(handle) >= 0;
        }

        public bool Dispatch(
            ulong quotaInMicroseconds
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, ulong, bool>)vtable[3];

            var result = fnPtr(
                thisPtr,
                quotaInMicroseconds
            );

            return result;
        }

        public int OpenWaitHandle(
            out IntPtr waitHandle
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, int>)vtable[4];

            var result = fnPtr(
                thisPtr,
                out waitHandle
            );

            return result;
        }
    }

    public sealed unsafe partial class IGameInputForceFeedbackEffect : SafeHandle
    {
        public override bool IsInvalid => handle == IntPtr.Zero;

        internal IGameInputForceFeedbackEffect(IntPtr handle, bool ownsHandle)
            : base(IntPtr.Zero, ownsHandle)
        {
            SetHandle(handle);
        }

        protected override bool ReleaseHandle()
        {
            return Marshal.Release(handle) >= 0;
        }

        public void GetDevice(
            out LightIGameInputDevice device
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, void>)vtable[3];

            fnPtr(
                thisPtr,
                out IntPtr device_handle
            );

            device = new(device_handle, ownsHandle: true);
        }

        public uint GetMotorIndex()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint>)vtable[4];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public float GetGain()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, float>)vtable[5];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public void SetGain(
            float gain
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, float, void>)vtable[6];

            fnPtr(
                thisPtr,
                gain
            );

        }

        public void GetParams(
            out GameInputForceFeedbackParams ffbParams
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputForceFeedbackParams, void>)vtable[7];

            fnPtr(
                thisPtr,
                out ffbParams
            );

        }

        public bool SetParams(
            in GameInputForceFeedbackParams ffbParams
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, in GameInputForceFeedbackParams, bool>)vtable[8];

            var result = fnPtr(
                thisPtr,
                in ffbParams
            );

            return result;
        }

        public GameInputFeedbackEffectState GetState()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputFeedbackEffectState>)vtable[9];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public void SetState(
            GameInputFeedbackEffectState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputFeedbackEffectState, void>)vtable[10];

            fnPtr(
                thisPtr,
                state
            );

        }
    }

    public unsafe ref partial struct LightIGameInputForceFeedbackEffect
    {
        private IntPtr handle;
        private bool ownsHandle;

        public bool IsInvalid => handle == IntPtr.Zero;
        public bool IsClosed { get; private set; }

        internal LightIGameInputForceFeedbackEffect(IntPtr handle, bool ownsHandle)
        {
            this.handle = handle;
            this.ownsHandle = ownsHandle;
            IsClosed = false;
        }

        public void Dispose()
        {
            if (!IsClosed && !IsInvalid && ownsHandle)
            {
                Marshal.Release(handle);
                IsClosed = true;
            }
        }

        public IntPtr DangerousGetHandle() => handle;

        public IGameInputForceFeedbackEffect ToSafeHandle()
        {
            // Invalidate this handle
            IsClosed = true;

            // Move handle to the new instance
            var handle = this.handle;
            this.handle = IntPtr.Zero;
            return new(handle, ownsHandle);
        }

        public static implicit operator LightIGameInputForceFeedbackEffect(IGameInputForceFeedbackEffect instance)
        {
            return new(instance.DangerousGetHandle(), ownsHandle: false);
        }

        public void GetDevice(
            out LightIGameInputDevice device
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, void>)vtable[3];

            fnPtr(
                thisPtr,
                out IntPtr device_handle
            );

            device = new(device_handle, ownsHandle: true);
        }

        public uint GetMotorIndex()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint>)vtable[4];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public float GetGain()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, float>)vtable[5];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public void SetGain(
            float gain
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, float, void>)vtable[6];

            fnPtr(
                thisPtr,
                gain
            );

        }

        public void GetParams(
            out GameInputForceFeedbackParams ffbParams
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out GameInputForceFeedbackParams, void>)vtable[7];

            fnPtr(
                thisPtr,
                out ffbParams
            );

        }

        public bool SetParams(
            in GameInputForceFeedbackParams ffbParams
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, in GameInputForceFeedbackParams, bool>)vtable[8];

            var result = fnPtr(
                thisPtr,
                in ffbParams
            );

            return result;
        }

        public GameInputFeedbackEffectState GetState()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputFeedbackEffectState>)vtable[9];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public void SetState(
            GameInputFeedbackEffectState state
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputFeedbackEffectState, void>)vtable[10];

            fnPtr(
                thisPtr,
                state
            );

        }
    }

    public sealed unsafe partial class IGameInputRawDeviceReport : SafeHandle
    {
        public override bool IsInvalid => handle == IntPtr.Zero;

        internal IGameInputRawDeviceReport(IntPtr handle, bool ownsHandle)
            : base(IntPtr.Zero, ownsHandle)
        {
            SetHandle(handle);
        }

        protected override bool ReleaseHandle()
        {
            return Marshal.Release(handle) >= 0;
        }

        public void GetDevice(
            out LightIGameInputDevice device
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, void>)vtable[3];

            fnPtr(
                thisPtr,
                out IntPtr device_handle
            );

            device = new(device_handle, ownsHandle: true);
        }

        public GameInputRawDeviceReportInfo* GetReportInfo()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputRawDeviceReportInfo*>)vtable[4];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public ref readonly GameInputRawDeviceReportInfo ReportInfo => ref *GetReportInfo();

        public nuint GetRawDataSize()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, nuint>)vtable[5];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public nuint GetRawData(
            nuint bufferSize,
            void* buffer
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, nuint, void*, nuint>)vtable[6];

            var result = fnPtr(
                thisPtr,
                bufferSize,
                buffer
            );

            return result;
        }

        public bool SetRawData(
            nuint bufferSize,
            void* buffer
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, nuint, void*, bool>)vtable[7];

            var result = fnPtr(
                thisPtr,
                bufferSize,
                buffer
            );

            return result;
        }

        public nuint GetRawData(byte[] buffer)
        {
            fixed (byte* ptr = buffer)
                return GetRawData((nuint)buffer.Length, ptr);
        }

        public nuint GetRawData(Span<byte> buffer)
        {
            fixed (byte* ptr = buffer)
                return GetRawData((nuint)buffer.Length, ptr);
        }

        public nuint GetRawData<T>(out T data)
            where T : unmanaged
        {
            fixed (T* ptr = &data)
                return GetRawData((nuint)sizeof(T), ptr);
        }

        public bool SetRawData(byte[] buffer)
        {
            fixed (byte* ptr = buffer)
                return SetRawData((nuint)buffer.Length, ptr);
        }

        public bool SetRawData(ReadOnlySpan<byte> buffer)
        {
            fixed (byte* ptr = buffer)
                return SetRawData((nuint)buffer.Length, ptr);
        }

        public bool SetRawData<T>(in T data)
            where T : unmanaged
        {
            fixed (T* ptr = &data)
                return SetRawData((nuint)sizeof(T), ptr);
        }

        public bool GetItemValue(
            uint itemIndex,
            out long value
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, out long, bool>)vtable[8];

            var result = fnPtr(
                thisPtr,
                itemIndex,
                out value
            );

            return result;
        }

        public bool SetItemValue(
            uint itemIndex,
            long value
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, long, bool>)vtable[9];

            var result = fnPtr(
                thisPtr,
                itemIndex,
                value
            );

            return result;
        }

        public bool ResetItemValue(
            uint itemIndex
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, bool>)vtable[10];

            var result = fnPtr(
                thisPtr,
                itemIndex
            );

            return result;
        }

        public bool ResetAllItems()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, bool>)vtable[11];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }
    }

    public unsafe ref partial struct LightIGameInputRawDeviceReport
    {
        private IntPtr handle;
        private bool ownsHandle;

        public bool IsInvalid => handle == IntPtr.Zero;
        public bool IsClosed { get; private set; }

        internal LightIGameInputRawDeviceReport(IntPtr handle, bool ownsHandle)
        {
            this.handle = handle;
            this.ownsHandle = ownsHandle;
            IsClosed = false;
        }

        public void Dispose()
        {
            if (!IsClosed && !IsInvalid && ownsHandle)
            {
                Marshal.Release(handle);
                IsClosed = true;
            }
        }

        public IntPtr DangerousGetHandle() => handle;

        public IGameInputRawDeviceReport ToSafeHandle()
        {
            // Invalidate this handle
            IsClosed = true;

            // Move handle to the new instance
            var handle = this.handle;
            this.handle = IntPtr.Zero;
            return new(handle, ownsHandle);
        }

        public static implicit operator LightIGameInputRawDeviceReport(IGameInputRawDeviceReport instance)
        {
            return new(instance.DangerousGetHandle(), ownsHandle: false);
        }

        public void GetDevice(
            out LightIGameInputDevice device
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, out IntPtr, void>)vtable[3];

            fnPtr(
                thisPtr,
                out IntPtr device_handle
            );

            device = new(device_handle, ownsHandle: true);
        }

        public GameInputRawDeviceReportInfo* GetReportInfo()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, GameInputRawDeviceReportInfo*>)vtable[4];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public ref readonly GameInputRawDeviceReportInfo ReportInfo => ref *GetReportInfo();

        public nuint GetRawDataSize()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, nuint>)vtable[5];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }

        public nuint GetRawData(
            nuint bufferSize,
            void* buffer
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, nuint, void*, nuint>)vtable[6];

            var result = fnPtr(
                thisPtr,
                bufferSize,
                buffer
            );

            return result;
        }

        public bool SetRawData(
            nuint bufferSize,
            void* buffer
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, nuint, void*, bool>)vtable[7];

            var result = fnPtr(
                thisPtr,
                bufferSize,
                buffer
            );

            return result;
        }

        public nuint GetRawData(byte[] buffer)
        {
            fixed (byte* ptr = buffer)
                return GetRawData((nuint)buffer.Length, ptr);
        }

        public nuint GetRawData(Span<byte> buffer)
        {
            fixed (byte* ptr = buffer)
                return GetRawData((nuint)buffer.Length, ptr);
        }

        public nuint GetRawData<T>(out T data)
            where T : unmanaged
        {
            fixed (T* ptr = &data)
                return GetRawData((nuint)sizeof(T), ptr);
        }

        public bool SetRawData(byte[] buffer)
        {
            fixed (byte* ptr = buffer)
                return SetRawData((nuint)buffer.Length, ptr);
        }

        public bool SetRawData(ReadOnlySpan<byte> buffer)
        {
            fixed (byte* ptr = buffer)
                return SetRawData((nuint)buffer.Length, ptr);
        }

        public bool SetRawData<T>(in T data)
            where T : unmanaged
        {
            fixed (T* ptr = &data)
                return SetRawData((nuint)sizeof(T), ptr);
        }

        public bool GetItemValue(
            uint itemIndex,
            out long value
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, out long, bool>)vtable[8];

            var result = fnPtr(
                thisPtr,
                itemIndex,
                out value
            );

            return result;
        }

        public bool SetItemValue(
            uint itemIndex,
            long value
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, long, bool>)vtable[9];

            var result = fnPtr(
                thisPtr,
                itemIndex,
                value
            );

            return result;
        }

        public bool ResetItemValue(
            uint itemIndex
        )
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, uint, bool>)vtable[10];

            var result = fnPtr(
                thisPtr,
                itemIndex
            );

            return result;
        }

        public bool ResetAllItems()
        {
            ThrowHelper.CheckDisposed(IsInvalid || IsClosed, "this");

            var thisPtr = handle;
            var vtable = *(void***)thisPtr;
            var fnPtr = (delegate* unmanaged[Stdcall]<IntPtr, bool>)vtable[11];

            var result = fnPtr(
                thisPtr
            );

            return result;
        }
    }
}